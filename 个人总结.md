# 个人总结

## ddd的基础概念

1. 领域（domain）：
   + 某专业知识，特定影响，行为流程的范围空间。这个主题的作用范围便是用户在软件里的作用领域。
2. 模型（model）：
   + 一种用来描述特定领域的一个方面的抽象，同时也用来解决该领域这个方面的问题。
3. 统一语言（ubiquitous	language）：
   + 是一种语言。该语言基于领域模型且被所有团队成员用于联系软件和特定环境下的行为。
4. 环境（context）：
   + 和词意几乎相同。模型只有在一个环境里才能合理地表达。
5. 有边界的环境（bounded	context）：
   + 环境的子环境，同理，有些模型只有在子环境下才能合理表达。

## ddd的核心设计理念

1. 聚焦于领域，也就是聚焦于环境里模型的表达，和模型的行为
2. 探索模型在领域里的行为与软件里的行为之间的相关联性，也就是把领域里的行为用软件里的行为描述，同时通过软件描述，可以预想出未来模型可能存在的行为
3. 在一个特定环境里，采用统一的通用语言

## 如何构建ddd

### 如何使模型生效

1. 层级分明。隔离领域模型的行为以及业务逻辑，完全杜绝构造层，ui层，甚至是应用逻辑的依赖，实现所有的代码都只和领域模型相关，同时把领域模型和ui层，构造层，应用逻辑完全分离。领域里的对象，没有权责去展示ui，存储数据，管理应用任务，只关心自身模型的表达。通过以上的层级可以使领域模型充满了清晰的业务逻辑。
2. 实体模型。实体是独一无二的，其独一性甚于其内部的属性。保持类的声明简单，并聚集于实体的生命周期和它的独立性上。这种模型必须和它意味着的东西一样。
3. 值对象。当只关注于这个对象的属性和行为时，它便是一个值对象。它给予属性意义，给予属性方法。保证值对象是不可更改的，保证它的所有操作不依赖于可变的状态。不要使一个值对象有唯一标识，同时也不要把一个值对象设计得过于复杂以至于难以从实体转换过来。
4. 实体事件。事件发生便是领域专家关心的事。一个实体有权责去跟踪自己的状态，有规则去矫正自己的生命周期。模型行为的信息可以被描述成事件。每一个事件都可以描述成领域对象。领域事件是一种丰满的领域模型，代表了在领域里发生的某些事。
5. 服务。有些时候，服务啥都不是。领域里的有些概念不是很自然无法描述成模型。强迫要求领域里的实体或者值扭曲成对象。当转变领域里的实体或者值对象不是这些对象的自然职责时，为模型添加一个操作作为一个独立的接口，并把它描述为服务。
6. 模型。选择那些可以叙述系统里的业务的同时包含了一系列领域概念抽象成模型。模型之间会产生耦合，但是这不会改变模型与领域概念的关系。探索模型之间的耦合意义，也就是在探索领域概念之间的关系。善待模型直到它成为一个高等级的领域概念，同时模型与代码之间的耦合也会弱化。
7. 聚合。实体或者值对象的集合聚合在一起，声明各自的边界。选择一个实体成为这个聚合的根，仅允许其他对象持有此根实体的引用。为这个根实体定义属性和行为，加强根实体的职责。（至于为啥要聚合，看书吧。。。）
8. 仓储。提供仓储服务仅给予那些聚合根，保持应用的逻辑专注与模型，通过仓储代理来所有的对象的存储和联系。（至于为啥不推荐其他模型有仓储，看书吧）
9. 工厂。构造复杂实体和值对象时推荐使用，同时自身不在有这个权责来创建自身。

### 软设计

1. 意图明显的接口。有意义的命名类和行为。最好能先写个测试。
2. 降低函数的副作用。把程序的大多数逻辑代码尽可能得重构为函数，而且是没有副作用的函数。
3. 断言。操作所需的状态判定的前提条件，推荐你写成断言的方式，如果不能直接code，写在单元测试里，或者写在文档或者图里。
4. 独立的类。尽管用了模型，但是当设计变得复杂，依赖或者模型添加，难以去解释这些设计。为了限制设计的复杂性，鲜明的模型概念更有利于理解。低级耦合是对象设计的原则。使得类可以可以独立理解，而且自身包含自身的边界。
5. 封闭操作。这个适用于，声明一个操作，而它的返回值类型就是参数本身。如果实现者有在操作中使用的状态值，那么实现者对于这个参数而言是有副作用的，所以这个操作的参数和操作的返回类型应该相同。一个封闭的操作提供了高等级的接口，而这个接口不依赖其他概念。这个模式适用于值对象。
6. 声明式的设计。减少硬编码。
7. 抽象公用的领域。
8. 概念的轮廓。函数太小，不利于理解，函数太大，不便解耦。分解设计的节点（操作啊，接口啊，类啊，聚合啊）到有凝聚力的小单元里，考量这样分解后在领域后的影响。观察分解后的影响，以及重构后的稳定性，寻找概念的轮廓来描述这些分解后的模式。把模型作为领域的一贯的方面来，首要是使得模型成为领域知识的最重要的
核心区域。

### 环境策略

1. 环境映射。每一个在项目里的模型都存在一个有边界的环境。环境甚至都包括了非对象继承的子系统。用通用语言命名每一个有边界的环境。描述这个模型之间联系的关键点，高亮任何分享，独立，影响机制。
2. 搭档关系。伪造搭档关系在两个环境之间的队伍里。实施一种流程为了合作开发，并且安排整合。团队必须合作在演化接口时，为了使接口互相需要。内部依赖会如期解决因为在同期需要发布。
3. 共享节点。团队共享一种小而精密的设计。由于边界的缘故，单独处理这个模型的子集，这种分享的模型有特殊的状态，必须和别的团队商议才能处理这种模型。
4. 拓展清晰的上下游关系，意味着下游成为了上游的主要任务。

### 设计策略

1. 专注核心区域。把其他区域撇开，定义核心区域，从一堆杂物，代码里给予它最有价值最特殊的核心概念，保持核心区域的范围小。从核心区域逐步向外拓展，找到别的模型，是的系统丰满起来。
2. 通用的子域。把这类的域独立起来模块化开发，给这些域低层级的优先权，核心开发人员越少接触这类项目。
3. 模型要声明是干啥的。
4. 高亮核心区域。也是写文档。
5. 分割概念，问题无非是是什么和怎么办，把这两种分离，暴露怎么办作为接口，这样领域里其他的节点就能关注在表达问题是什么？分解子域变成集群，聚合服务封装复杂的操作。
6. 重构模型到分子级别的概念，这些模型充当支持者的角色（包括模糊不清的概念），通过减少模型之间的关系链接，加强了模型的特殊性。
7. 抽象核心模型。。越抽象越好，因为便于理解？？？

## 大型项目的设计

在整个项目进程中设计一种角色，权责，或者关系，允许有些人理解项目各个部分尽管并不知道这部分的细节。

### 迭代顺序

使得大型框架的概念和应用一起进化，可能得话，一直改变。不要约束设计细节和模型概念。

少既是多。

### 系统隐喻

### 职责层级

观察，模型里的概念依赖，行为变化等。如果你定义了一个自然的能力在领域里，把他们转化为有边界的抽象职责。这些职责能阐述你设计的目的。重构模型，使得模型里每一个对象都有适当的职责。

### 知识等级

**see	Fowler,	M.	1997.	Analysis	Patterns:	Reusable	Object	Models,	Addison-Wesley.**

### 插件式框架

提取抽象的核心接口或者行为，创建一个框架允许分发这种实现。同样的，允许任意应用使用这些组件，这样操作也可以通过抽象接口来实现。



