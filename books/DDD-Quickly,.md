# 《领域驱动设计-精简版》

## 何为 领域驱动设计

我们怎样才能让软件和领域和谐相处呢？最佳的方式是让软件成为领域的反射（映射）。软件需要具现领域里重要的核心概念和元素，并精确实现它们之间的关系。软件需要对领域进行建模。

模型是我们对目标领域的内部展现方式，它是非常必须的，会贯穿设计和开发的全过程。在设计过程中我们记住并会对模型的很多方面进行引用。

我们需要组织信息，将其系统化，把它分割成小一点的信息块，将这些信息块分类放到逻辑模块中，每次只处理其中的一个逻辑模块。我们需要忽略领域中的很多部分，因为领域包含了如此之多的信息，不能一下子放到一个模型中。而且，它们当中的很多部分我们也不必去考虑。

**模型是软件设计中最基础的部分。**

我们需要就这个模型跟领域专家进行交流，跟资深的设计人员进行交流，跟开发人员进行交流。模型是软件的根本，但我们需要找到一些方法来表现它，让它和其他事物交流。

常见的一种方式是将模型图形化：图、用例、画和图片等。另一种方式是写，我们会写下我们对领域的愿景。还有一种方式是使用语言，我们能够也应该针对要交流的领域内的特定问题建立一种语言。在以后的章节中我们会详细讲解它们，但主要观点是说，**我们需要用模型来交流**

当我们有一个表现的模型时，就可以开始做代码设计了。这跟软件设计有很大的不同。软件设计类似于构建房子的架构，那是跟一个总图相关的。从另一个方面讲，代码设计是非常细节性的工作，类似于在一面墙上定位一幅油画。

## 构建领域知识

这儿我们不会试图演化成一个完整的交通控制系统，只会关注其中的一个小的子集：**飞行监控系统**。这个提到的项目是一个监控系统，它会跟踪在指定区域内的任意航班，判断班机是否遵照了预定的航线，以及是否有可能发生碰撞。

控制人员和你自己都认同每一个飞行器有一个起始机场和目的机场。所以我们找到了“飞行器”、“起始机场”和“目的机场”。(aircraft)-(destination)-(departure)



那么，飞机从某地起飞又在另一地降落。但空中发生了什么？班机会按照什么路线航行？事实上，我们更关心的是它在航时所发生的事情。控制人员说会给每架飞机指派一个飞行计划，飞行计划会用来描述假定的整个空中旅行。当听到“飞行计划”时，你可能会在你脑海中想到这是一个飞机在空中必须遵守的路径。在后边的讨论中，你会听到一个有趣的词：路线(route)。它能很快引起你的注意，这是个很好的理由。路线包含了飞机航行中的一个重要概念。那就是飞机在飞行时要做的事，它们必须遵照一条路线。很明显飞机的出发点和目标点也就是路线的开始和结束点。所以，不同于将飞行器与出发点和目标点管理，看上去更自然的是将它与“路线”进行关联，然后路线再与适当的出发点和目的地关联。

(aircraft)-(route)-(departure)/(destination)

跟控制人员交流飞行器需要遵照的路线时，你会发现路线由小的区间段组成，这些区间段按照一定的次序组织起来就会构成从出发点到目的地的一条曲线。这条线被假定穿过预定的方位点。所以，路线可以被考虑成一系列连续的方位点。

(aircraft)-(route)-(fix)-(3DPoints)

这副图显示了另外一个元素，事实上路线中需要遵照的每个方位是一个在空间中的一个点，它表现为一个 3 维的点。但当你跟控制人员交谈时，你会发现他并不按这种方式思考。实际上，他将路线看作是飞机航班在地球上的映射。方位只是地球表面上的点，可以由经度和纬度来决定。

(aircraft)-(route)-(fix)-(2DPoints)

**你和领域专家在交谈，你们在交换知识。你开始问问题，然后他们回应。当他们这样做时，他们从空中交通领域挖掘出基础性的概念。那些概念可能看上去未经雕琢、没有经过组织，但它们却是理解领域的基础。你需要尽可能多地从专家处学习领域知识。通过提出正确的问题，正确地处理得到的信息，你和专家会开始勾勒领域的骨架视图，也就是领域模型。这种骨架视图既不完整也不能保证是正确的，但它却是你需要的开始点，可以尽力判断出领域的基础性概念。**

## 通用语言 Ubiquitous Language

**领域驱动设计的一个核心的原则是使用一种基于模型的语言。因为模型是软件满足领域的共同点，它很适合作为这种通用语言的构造基础。**

**领域专家会反对用那些很笨拙的或者不适当的字眼或者结构来传达对领域的理解。如果领域专家不能理解模型或者语言中的某种内容，那么就如同是说这种内容存在某种错误。从另一方面讲，开发人员应该留意那些与他们试图呈现在设计中的内容存在二义性或者不一致的部分。**

### 创建通用语言

(aircraft)-(flight plan)-(route)-(fix)-(2DPoints)

然而，在实际生活中像这样的对话太冗长了，人们经常间接地讨论事情，或者深入到非常细节的部分，或者会选择错误的概念。这会让语言的产生过程非常艰难。为了解决这点，所有的团队成员应该都意识到需要建立一种通用的语言，并应保持专注核心的部分，在任何需要之时使用这种语言。我们应该尽可能少地在这种场景中使用我们自己的行话，应该使用通用语言，因为它能帮助我们更清晰更精确地交流。

**强烈建议开发人员把这些模型中的主要概念实现到代码中。**

这非常有帮助，它会让代码更可读，让模型得到完美实现。代码表现模型会让项目得益，如果代码没有得到适当地设计，在模型变大或代码中发生了变化时，会导致意料之外的结果。

这些文档甚至有可能是手绘的，因为这传递了一种感觉：它们是临时的，可能不久就要发生变化。这种感觉是对的，因为模型从一开始到它达到比较稳定的状态会发生很多次变化。

**任何领域都能被表现成多种模型，每一种模型都能用不同的方式表现成代码。**对每一个特殊问题而言，可能会对应不止一个解决方案。我们应该选择哪一个呢？拥有一个看上去正确的模型不代表模型能被直接转换成代码。也或者它的实现会违背某些我们所不建议的软件设计原则呢。选择一个能够被轻易和准确转换成代码的模型很重要。最根本的问题是：我们应该如何动手处理从模型到代码的转换。

## 模型驱动设计的基本构成要素 模型驱动设计的基本构成要素 模型驱动设计的基本构成要素

一个通用领域驱动设计的架构性解决方案包含 4 个概念层：

1. UI 负责向用户展现信息以及解释用户命令。
2. APP 很薄的一层，用来协调应用的活动。它不包含业务逻辑。它不保留业务对象的状态，但它保有应用任务的进度状态。
3. Domain 本层包含关于领域的信息。这是业务软件的核心所在。在这里保留业务对象的状态，对业务对象和它们状态的持久化被委托给了基础设施层。
4. Infrastructure 本层作为其他层的支撑库存在。它提供了层间的通信，实现对业务对象的持久化，包含对用户界面层的支撑库等作用。

领域层应该关注核心的领域问题。它应该不涉及基础设施类的活动。用户界面既不跟业务逻辑紧密捆绑也不包含通常属于基础设施层的任务。在很多情况下应用层是必要的。它会成为业务逻辑之上的管理者，用来监督和协调应用的整个活动。

*一条箴言是：如果值对象是可共享的，那么它们应该是不可变的。值对象应该保持尽量的简单。*

## 服务

**当我们分析领域并试图定义构成模型的主要对象时，我们发现有些方面的领域很难映射成对象。对象要通常考虑的是拥有属性，对象会管理它的内部状态并暴露行为。**

在我们开发通用语言时，领域中的主要概念被引入到语言中，语言中的名词很容易被映射成对象。语言中对应那些名词的动词变成那些对象的行为。

但是有些领域中的动作，它们是一些动词，看上去却不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单的把它们合并到某个实体或者值对象中。给一个对象增加这样的行为会破坏这个对象，让它看上去拥有了本该属于它的功能。

但是，要使用一种面向对象语言，我们必须用到一个对象才行。我们不能只拥有一个单独的功能，它必须附属于某个对象。通常这种行为类的功能会跨越若干个对象，或许是不同的类。例如，为了从一个账户向另一个账户转钱，这个功能应该放到转出的账户还是在接收的账户中？感觉放在这两个中的哪一个也不对劲。

当这样的行为从领域中被识别出来时，最佳实践是将它声明成一个服务。这样的对象不再拥有内置的状态了，它的作用是为了简化所提供的领域功能。服务所能提供的协调作用是非常重要的，一个服务可以将服务于实体和值对象的相关功能进行分组。最好显式声明服务，因为它创建了领域中的一个清晰的特性，它封装了一个概念。把这样的功能放入实体或者值对象都会导致混乱，因为那些对象的立场将变得不清楚。

一个服务应该不是对通常属于领域对象的操作的替代。我们不应该为每一个需要的操作来建立一个服务。但是当一个操作凸现为一个领域中的重要概念时，就需要为它建立一个服务了。以下是服务的 3个特征：

1. 服务执行的操作涉及一个领域概念，这个领域概念通常不属于一个实体或者值对象。
2. 被执行的操作涉及到领域中的其他的对象。
3. 操作是无状态的。

当领域中的一个重要的过程或者变化不属于一个实体或者值对象的自然职责时，向模型中增加一个操作，作为一个单独的接口将其声明一个服务。根据领域模型的语言定义一个接口，确保操作的名字是通用语言的一部分。让服务变得无状态。

使用服务时保持领域层的隔离非常重要。很容易弄混属于领域层的服务和属于基础设施层的服务。服务层也可能有服务，这会继续增加层级的复杂性。这些服务甚至更难从与领域层中的近似的服务中分离开来。当我们在设计阶段建立模型时，我们需要确保领域层保持从其他层中隔离开来。

不论是应用服务还是领域服务，通常都是建立在领域实体和值对象的上层，以便直接为这些相关的对象提供所需的服务。决定一个服务所应归属的层是非常困难的事情。如果所执行的操作概念上属于领域层，那么服务就应该放到这个层。如果操作和领域对象相关，而且确实也跟领域有关，能够满足领域的需要，那么它就应该属于领域层。

## 模块

对一个大型的复杂项目而言，模型趋向于越来越大。模型到达了一个作为整体很难讨论的点，理解不同部件之间的关系和交互变得很困难。基于此原因，很有必要将模型组织进模块。模块被用来作为组织相关概念和任务以便降低复杂性的一种方法。

有很多类型的内聚。最常用到的两个是通信性内聚和功能性内聚。通信性内聚通常在模块的部件操作相同的数据时使用。把它们分到一组很有意义，因为它们之间存在很强的关联性。功能性内聚在模块中的部件协同工作以完成定义好的任务时使用。这被认为是最佳的内聚类型。

我们应该选择那些能够表述系统内涵并且包含具有内聚性概念集的模块。这种方式通常会使得模块之间松耦合，但是如果没有让模型中的概念更加清晰明白，它也能找到一个或许可以作为模块基础的宏观概念，使得各个元素有机地组合在一起。寻找每一个能够被独立理解和辨别的概念间的低耦合。重定义模型，直到它被按照高级别的领域概念区分开来，而且对应的代码也被很好地解耦合。

## 聚合

领域对象在它们的生命期内会历经若干种状态，直到最后消亡。有时它们会被保存到一个永久的位置，例如数据库中，这样可以在以后的日子里被检索到，或者被存档。有时它们会被完全从系统中清除掉，包括从数据库和归档介质上。

聚合是一个用来定义对象所有权和边界的领域模式。工厂和资源库是另外的两个设计模式，用来帮助我们处理对象的创建和存储问题。

我们将从聚合开始讨论。

一个模型会包含众多的领域对象。不管在设计时做了多少考虑，我们都会看到许多对象会跟其他的对象发生关联，形成了一个复杂的关系网。这些关联的类型有很多种。对模型中的每个可导航的关联而言，都应该有对应的软件机制来强调它。

领域对象间实际的关联在代码中结束，有时甚至却在数据库中。客户和用它名字开立的银行账户之间存在的一个 1 对 1 的关系会被表现为两个对象之间的引用，并且在两个数据库表中隐含着一个关联关系，一个表存放客户信息，另一个表存放账户信息。

**来自模型的挑战是通常不让它们尽量完整，而是让它们尽量地简单和容易理解。这意味着，直到模型中嵌入了对领域的深层理解，否则就要时常对模型中的关系进行消减和简化。**

一个 1 对多的关联关系就更复杂了，因为它涉及到了相关的多个对象。这种关系可以被简单转化成一个对象和一组其他对象之间的一个关联，虽然这并不总能行得通。

多对多的关联关系大部分情况下是双向的。这又增加了复杂度，使得对这样的对象的生命周期管理变得困难。关联的数字应该被尽可能消减。

首先，要删除模型中非本质的关联关系。它们可能在领域中是存在的，但它们在我们的模型中不是必要的，所以我们要清除
它们。其次，可以通过增加约束的方式来消减多重性。如果很多对象满足一种关系，那么在这个关系上加入正确的约束后，很有可能只有一个对象会继续满足这种关系。第三，很多时候双向关联可以被转换成非双向的关联。

每一辆汽车都有一个引擎，并且引擎在运转时，都会属于一辆汽车。这种关系是双向的，但是很容易成为汽车拥有引擎，而不用考虑反向的。

在我们消除和简化了对象间的关联后，我们仍然会遭遇到很多的关系。一个银行系统会保留并处理客户数据。这些数据包括客户个人数据（例如姓名、地址、电话号码、工作描述等）和账户数据：账户、余额、执行的操作等。当系统归档或者完全删除一个客户的信息时，必须要保证所有的引用都被删除了。如果许多对象保有这样的引用，则很难确保它们全被清除了。同样，如果一个客户的某些数据发生了变化，系统必须确保在系统中执行了适当的更新，数据一致性必须得到保证。这通常被提交到数据库层面进行处理。事务通常用来确保数据一致性。但是如果模型没有被仔细地设计过，会产生很大程度的数据库争夺，导致性能极差。当数据库事务在这样的操作中担负重要角色时，我们会期望直接在模型中解决跟数据一致性相关的一些问题。

通常也有必要确保不变量。不变量是在数据发生变化时必须维护的那些规则。这在许多对象与数据发生变化的对象保持引用时更难实现。

因此，使用聚合。聚合是针对数据变化可以考虑成一个单元的一组相关的对象。**聚合使用边界将内部和外部的对象划分开来。**每个聚合有一个根。这个根是一个实体，并且它是外部可以访问的唯一的对象。根可以保持对任意聚合对象的引用，并且其他的对象可以持有任意其他的对象，但一个外部对象只能持有根对象的引用。如果边界内有其他的实体，那些实体的标识符是本地化的，只在聚合内有意义。

**聚合是如何保持数据一致性和强化不变量的呢？因为其他对象只能持有根对象的引用，这意味着它们不能直接变更聚合内的其他的对象。它们所能做的就是对根进行变更，或者让根来执行某些活动。根能够变更其他的对象，但这是聚合内包含的操作，并且它是可控的。**如果根从内存中被删除或者移除，聚合内的其他所有的对象也将被删除，因为再不会有其他的对象持有它们当中的任何一个了。当针对根对象的修改间接影响到聚合内的其他的对象，强化不变量变得简单了，因为根将做这件事情。如果外部对象能直接访问内部对象并且变更它们时，这将变得越发困难。在这种情况下想强化不变量意味着将某些逻辑放到外部对象中去处理，这不是我们所期望的。

根对象可能将内部的临时引用传递给外部对象，作为限制，当操作完成后，外部对象不能再持有这个引用。一个简单的实现方式是向外部对象传递一个值对象的拷贝。在这个对象上发生了什么将不再重要，因为它不会以任何方式影响到聚合的一致性。

**如果聚合对象被保存到数据库中，只有根可以通过查询来获得。其他的对象只能通过导航关联来获得。**

## 工厂

实体和聚合通常会很大很复杂，根实体的构造函数内的创建逻辑也会很复杂。实际上通过构造器努力构建一个复杂的聚合也与领域本身通常做的事情相冲突，在领域中，某些事物通常是由别的事物创建的（例如电器是在组装线上被创建的）。这看上去是用打印机构建自己。

当一个客户程序对象想创建另一个对象时，它会调用它的构造函数，可能传递某些参数。但是当对象构建是一个很费力的过程时，对象创建涉及了好多的知识，包括：关于对象内部结构的，关于所含对象之间的关系的以及应用其上的规则等。这意味着对象的每个客户程序将持有关于对象构建的专有知识。这破坏了领域对象和聚合的封装。如果客户程序属于应用层，领域层的一部分将被移到了外边，扰乱整个设计。

一个对象的创建可能是它自身的主要操作，但是复杂的组装操作不应该成为被创建对象的职责。组合这样的职责会产生笨拙的设计，也很难让人理解。

工厂用来封装对象创建所必需的知识，它们对创建聚合特别有用。当聚合的根建立时，所有聚合包含的对象将随之建立，所有的不变量得到了强化。

因此，转变创建复杂对象和聚合的实例的职责给一个单独的对象，虽然这个对象本身在领域模型中没有职责，但它仍是领域设计的一部分。提供一个封装了所有复杂组装的接口，客户程序将不再需要引用要初始化的对象的具体的类。

当创建一个工厂时，我们被迫违反一个对象的封装原则，而这应该小心行事。每当对象中发生了某种变化时，会对构造规则或者某些不变量造成影响，我们需要确认工厂也被更新以支持新的条件。工厂和它们要创建的对象是紧密关联的。这可能是个弱点，但它也有长处。一个聚合包含了一系列密切相关的对象。跟的构建与聚合内的其他对象的创建是相关的。会有一些逻辑放置到聚合中，这些逻辑不属于任何一个对象，因为它总跟其他对象的构建有关。看上去，使用一个专用的工厂类，给定创建整个聚合的任务比较合适，聚合中的包含的规则、约束和不变量将被确保在聚合内有效。这个对象会保持简单，并将完成特定的目的，不会造成复杂的构建逻辑的混乱。

实体工厂和值对象工厂是有差异的。值通常是不可变的对象，并且其所有的必需的属性需要在创建时完成。当一个对象被创建时，它是有效的，也是最终的，不会再发生变化。实体是非不可变的。它们会在以后发生变化，前面提及过设置某些属性时需要考虑所有的不变量。另一个差异源于实体需要标识符，而值对象不需要。

有时工厂是不需要的，一个简单的构造函数就足够了。在如下情况
下使用构造函数：

1.  构造过程并不复杂。
2. 对象的创建不涉及到其他对象的创建，所有的属性需要传递给构造函数。
3. 客户程序对实现很感兴趣，可能希望选择使用策略模式。
4. 类是特定的类型，不涉及到继承，所以不用在一系列的具体实现中进行选择。

工厂需要从无到有创建一个新对象，也或者它们需要从先前已经存在但可能已经持久化到一个数据库中的对象进行重建。将实体对象从它们所在的数据库中取回内存中，涉及了一个和创建一个新对象完全不同的过程。对象已经有一个了，对不变量的违反将区别对待。当一个新的对象从无到有创建时，任何对不变量的违反都会产生一个异常。我们不能在对象从数据库重建时也这样处理。**这个对象需要的是如何修复，这样它们才是可工作的，否则就会有数据的丢失。**

## 资源库

在模型驱动设计中，对象从被创建开始，直到被删除或者被归档结束，是有一个生命周期的。一个构造函数或者工厂可应用来处理对象的创建。创建对象的整体作用是为了使用它们。在一个面向对象的语言中，我们必须保持对一个对象的引用以便能够使用它。为了获得这样的引用，客户程序必须创建一个对象或者通过导航已有的关联关系从另一个对象中获得它。

问题是现在客户程序必须先拥有一个对根的引用。对大型的应用而言，这会变成一个问题因为我们必须保证客户始终对需要的对象保持一个引用，或者是对关注的对象保有引用。在设计中使用这样的规则将强制要求对象持有一系列它们可能其实并不需要保持的一系列的引用。这增加了耦合性，创建了一系列本不需要的关联。

要使用一个对象，则意味着这个对象已经被创建完毕了。如果这个对象是聚合的根，那么它是一个实体，它会被保持到一个被持久化的状态，可能是在数据库中，也可能是其他的持久化形式。如果它是一个值对象，它会通过一个实体经由对关联的导航来获得。我们可以推导出大部分的对象可以从数据库中直接获取到。这解决了获取对象引用的问题。当一个客户程序需要使用一个对象时，它可以访问数据库，从中检索出对象并使用它。**这看上去是个非常快捷并且简单的解决方案，但它对设计会产生负面的影响。**

数据库是基础设施的一部分。一个不好的解决方案是客户程序必须知道要访问数据库所需的细节。例如，客户需要创建 sql 查询语句来检索所需的数据。数据库查询可能会返回一组记录，甚至暴露其内部的更细节信息。

当许多客户程序不得不直接从数据库创建对象时，会导致这样的代码在整个模型中四散。从这点上讲领域模型做出了妥协。它必须处理许多基础设施的细节而不是处理领域概念。

如果我们做出了一个对数据库进行变更的变更那会怎么样呢？所有四散的代码需要变更以便能够访问新的存储。当客户代码直接访问一个数据库时，它极有可能存储聚合中的一个内部对象。这会破坏聚合的封装性，带来未知的结果。

**客户程序需要有一个获取已存在领域对象引用的实际方式。**如果基础设施让这变得简单，客户程序的开发人员可能会增加更多的可导航的关联进一步混乱模型。**从另一方面讲，他们可能使用查询从数据库中获取所需的数据，或者拿到几个特定的对象，而不是通过聚合的根来递归。**领域逻辑分散到查询和客户代码中，实体和值对象变得更像数据容器。应用到众多数据库访问的基础设施的技术复杂性会迅速蔓延在客户代码中，开发人员不再关注领域层，所做的工作跟模型无关了。最终的结果是丢失了对领域的关注，设计做了妥协。

因此，使用一个资源库，它的目的是封装所有获取对象引用所需的逻辑。领域对象不需处理基础设施，以得到领域中对其他对象的所需的引用。只需从资源库中获取它们，于是模型重获它应有的清晰和焦点。

资源库会保存对某些对象的引用。当一个对象被创建出来时，它可以被保存到资源库中，然后以后使用时可从资源库中检索到。如果客户程序从资源库中请求一个对象，而资源库中并没有它，就会从存储介质中获取它。换种说法是，资源库作为一个全局的可访问对象的存储点而存在。

资源库可能包含一定的策略。它可能基于一个特定的策略来访问某个或者另一个持久化存储介质。它可能会对不同类型的对象使用不同的存储位置。最终结果是领域模型同需要保存的对象和它们的引用中解耦，可以访问潜在的持久化基础设施。

资源库可能包含一定的策略。它可能基于一个特定的策略来访问某个或者另一个持久化存储介质。它可能会对不同类型的对象使用不同的存储位置。最终结果是领域模型同需要保存的对象和它们的引用中解耦，可以访问潜在的持久化基础设施。

资源库可能包含用来访问基础设施的细节信息，但它的接口应非常简单。资源库应该拥有一组用来检索对象的方法。客户程序调用这样的方法，传递一个或者多个代表筛选条件的参数用来选择一个或者一组匹配的对象。实体可能通过传递其标识符被轻易指定。其他选择条件可能由一组对象的属性构成。资源库将针对这组条件来比对所有的对象，并返回符合条件的那些对象。资源库接口可能包含用来执行某些辅助计算（例如特定类型对象的数量）的方法。

**看上去资源库的实现可能会非常类似于基础设施，但资源库的接口是纯粹的领域模型。**

工厂和资源库之间存在一定的关系。它们都是模型驱动设计中的模式，它们都能帮助我们关联领域对象的生命周期。然而工厂关注的是对象的创建，而资源库关心的是已经存在的对象。资源库可能会在本地缓存对象，但更常见的情况是需要从一个持久化存储中检索它们。对象可以用构造函数创建，也可以被传递给一个工厂来构建。从这个原因上讲，资源库也可以被看作一个工厂，因为它创建对象。不过它不是从无到有创建新的对象，而是对已有对象的重建。我们将不把资源库视为一个工厂。工厂创建新的对象，而资源库应该是用来发现已经创建过的对象。

当一个新对象被添加到资源库时，它应该是先由工厂创建过的，然后它应该被传递给资源库以便将来保存它。另外要注意的是工厂是“纯的领域”，而资源库会包含对基础设施的连接，如数据库。

## 持续重构

**我们被教教授的关于建模的第一件事是阅读业务规范，从中寻找名词和动词。名词被转换成类，而动词则成为方法。这是一种简化，将产生浅层次的模型。所有的模型开始时都缺乏深度，但我们可以面向越来越深的理解来重构模型。**

当我们跟领域专家交谈时，我们交互了很多的思想和知识。某些概念成为了通用语言，但也有些一直未被重视。它们是隐式概念，用来解释以及在领域中的其他的概念。在精化设计的过程中，某些隐式概念吸引了我们注意力。我们发现它们当中某些在设计中担当了重要的角色。因此我们需要将这些概念显式化。我们应该为它们建立类和关系。当它们发生时，我们就拥有了突破的机会。

有时设计的部分可能不会那么清晰，一堆关系会让路径的计算变得难以进行，或者计算的过程会复杂到难以理解。这在设计中显得极其笨拙，但这也是寻找隐藏的概念的绝佳之所，可能我们错过了什么。如果某个关键概念在破解谜团时缺失了，其他的事物就不得不替代它完成它的功能。这会让某些对象变胖，给它们增加了一些本不应该属于它的行为。设计的清晰度受到了破坏。努力寻找是否有缺失的概念，如果找到一个，就把它显式化。对设计进行重构让它更简单更具柔性。

在让概念显式化时，还有其他一些非常有用的概念：约束、过程和规约。

+ 约束是一个很简单的表示不变量的方式。无论对象的数据发生了变化，都要考虑不变量。这可以简单地通过把不变量的逻辑放置在一个约束中去实现它。将约束置于一个单独的方法让它显示化有很多优点。它很容易阅读。如果约束变得更复杂，这可以为向该方法增加更多逻辑提供增长空间。
+ 过程通常在代码中被表现为 procedure。从我们开始使用面向对象语言后我们就不再用一个过程化的方法，所以我们需要为过程选择一个对象，然后给它增加行为。最好的实现过程的方式是使用服务。其他的处理过程的不同的方式如，将算法封装进一个策略对象。并不是所有的过程都必须显式化。如果通用语言中提到了某个过程，那就是将它显式实现的时机了。
+ 规约。简单得说，规约是用来测试一个对象是否满足特定条件的。领域层包含了应用到实体和值对象上的业务规则。那些规则通常与它们要应用到的对象合成一体。在这些规则中，某些只是用来回答“是”和“否”的一组问题的，某些规则可以被表现成一系列操作布尔值的逻辑上的操作，最终结果也是一个布尔值。
  + 案例是在一个客户对象上执行测试，看它是否符合特定的信用条件。这个规则可以被表现成一个方法，起名叫isEligible（），并且可以附加到客户对象上。但这个规则不是严格基于客户的数据进行操作的一个简单的方法。评估规则涉及到验证客户的信用，检查他过去是否支付过他的债务，检查他是否具有足够的余额等。这样的业务规则可能非常的大，非常复杂，让对象的功能肿胀，不再满足其原始的目的。在这种情况下我们可能会试图将整个规则移动到应用层，因为它看上去已经超越了领域层了。实际上，到了重构的时候了。规则应该被封装到一个负责它的对象中，这将成为客户的规约，并且被保留在领域层中。新的对象将包含一系列布尔方法，这些方法用来测试一个客户对象是否符合某种信用。每一个方法担负了一个小的测试的功能，所有的方法可以通过组合对某个原始问题给出答案。如果业务规则不能被包含到一个规约对象中，对应的代码会遍布到无数的对象中，让它不再一致。

## 保持模型一致性

我们可以这样说，其中的一个团队创建了一个模块，然后提供给其他的团队使用。某个团队的开发人员开始在自己的模块中使用这个模块，但发现还缺少一些功能，于是他增加了这个功能并放到代码库里面，以便所有的人都能使用。但是他也许没有意识到，这其实是对模型的一个变更，这个变更很有可能破坏系统的功能。这种情况很容易发生，因为没有人会花时间去完全理解整个模型。每个人都知道自己的后院里有什么，但对其他地方则并不是非常了解。

模型的首要需求是一致性，条款统一和没有矛盾。模型的内部一致被称为“统一”。

不是试图保持一个迟早要四分五裂的大模型，我们应该做的是有意识地将大模型分解成数个较小的部分。只要遵守相绑定的契约，整合得好的小模型会越来越有独立性。每个模型都应该有一个清晰的边界，模型之间的关系也应该被精确地定义。

## 界定的上下文

每一个模型都有一个上下文。在我们处理一个独立的模型时，上下文是固定的。我们不需要去定义它。在任何大型项目中都存在多个模型。如果基于不同模型的代码被合并，软件就变得不稳定、不可靠而且很难理解。团队之间的沟通也会不通畅。在哪些上下文里不应该有模型通常都不是非常明确的。

如何把一个大的模型分解成小的部分没有什么具体的公式。尽量把那些相关联的以及能形成一个自然概念的因素放在一个模型里。模型应该足够小，以便能分给一个团队去实现。模型的上下文是一个条件集合，用这些条件可以确保应用在模型里的条款都有一个明确的含义。

这儿主要的思想是定义模型的范围，画出它的上下文的边界，然后尽最大可能保持模型的一致性。要在模型涵盖整个企业项目时保持它的纯洁是很困难的，但是在它被限定到一个特定区域时就相对容易很多。要在应用到模型的地方明确定义上下文。在团队组织里明确定义边界，在应用的具体部分明确定义用法，以及像代码库和数据库 Schema 的物理显示。保持模型在这些边界里的严格一致，不要因外界因素的干扰而有异动。

被界定的上下文不是模型。界定的上下文提供有模型参与的逻辑框架。模块被用来组织模型的要素，因此界定的上下文包含模块。

当不同的团队不得不共同工作于一个模型时，我们必须小心不要踩到别人的脚（译者注：意思为各司其职，不越界）。要时刻意识到任何针对模型的变化都有可能破坏现有的功能。当使用多个模型时，每个人可以自由使用自己的那一部分。我们都知道自己模型的局限，都恪守在这些边界里。我们需要确保模型的纯洁、一致和完整。

一旦界定的上下文被定义，我们就必须保持它的完整性。但多人工作于同一个界定的上下文时，模型很容易被分解。团队越大，问题越大，不过通常只有三四个人会遇到严重的问题。但是，系统被破坏成更小的上下文后，基本上也就失去了完整性和一致性的价值。

就是一个团队工作于一个界定的上下文，也有犯错误的空间。在团队内部我们需要充分的沟通，以确保每个人都能理解模型中每个部分所扮演的角色。如果一个人不理解对象间的关系，他就可能会以和原意完全相反的方式修改代码。如果我们不能百分之百地专注于模型的纯洁性，就会很容易犯这种错误。团队的某个成员可能会在不知道已经有自己所需代码的情况下增加重复代码，或者担心破坏现有的功能而不改变已有的代码选择重复增加。

持续集成是基于模型中概念的集成，然后再通过测试实现。任何不完整的模型在实现过程中都会被检测出来。持续集成应用于界定的上下文，不会被用来处理相邻上下文之间的关系。

## 上下文映射

上下文映射（Context Map）是指抽象出不同界定上下文和它们之间关系的文档，它可以是像下面所说的一个试图（Diagram），也可以是其他任何写就的文档。详细的层次各有不同。它的重要之处是让每个在项目中工作的人都能够得到并理解它。

每个界定的上下文都应该有一个作为 Ubiquitous Language 一部分的名字。这在团队之间沟通整个系统的时候非常有用。每个人也应该知道每个上下文的界限以及在上下文和代码之间的映射等。一个通常的做法是先定义上下文，然后为每个上下文创建模型，再用一个约定的名称指明每个模型所属的上下文。

## 客户--供应商

我们经常会遇到两个子系统之间关系特殊的时候：一个严重依赖另一个。两个子系统所在的上下文是不同的，而且一个系统的处理结果被输入到另外一个。它们没有共享的内核，因为从概念上理解也许不可以有这样一个内核，或者对两个子系统而言要共享代码在技术上也不可能实现。

我们曾讨论了一个关于在线商店应用的模型，包括报表和通讯两部分内容。我们已经解释说最好要为所有的那些上下文创建各自分开的模型，因为只有一个模型时会在开发过程中遇到瓶颈和资源的争夺。假设我们同意有分开的模型，那么在Web 商店字系统和报表系统间的关系是什么样子的呢？共享内核看上去不是好的选择。子系统很可能会用不同的技术被实现。一个是纯浏览器体验，而另一个可能是丰富的 GUI 应用。尽管如果报表应用是用 Web 接口实现，各自模型的注意概念也是不同的。也许会有越界的情况，但还不足以应用共享内核。所以我们选择走不同的道路。另外，E 商店子系统并不全依赖报表系统。E 商店应用的用户是 Web 客户，是那些浏览商品并下单的人。所有的客户、商品和订单数据被放在一个数据库里。就是这样。E 商店应用不会真的关心各自的数据发生了什么。而同时，报表应用非常关心和需要由 E 商店应用保存的数据。它还需要一些额外的信息以执行它提供的报表服务。客户可能在购物篮里放了一些商品，但在结账的时候又去掉了。某个客户访问的链接可能多于其他人等。这样的信息对 E 商店应用没有什么意义，但是对报表应用却意义非凡。**由此，供应商子系统不得不实现一些客户子系统会用到的规范。这是联系两个子系统的纽带。**

另外一个和所用到的数据库相关联的需求是它的 Schema。两个应用将使用同一个数据库。如果 E 商店应用是唯一访问数据库的应用，那么数据库 Schema 可以在任何时间被改变以反应它的需要。但是报表子系统也需要访问数据库，所以它需要一些 Schema 的稳定性。在开发过程中，数据库 Schema 一点也不能改变的情况是不可想像的。

当我们面对这样一个场景时，应该就开始“演出”了。报表团队应该扮演客户角色，而 E 商店团队应该扮演供应商角色。两个团队应该定期碰面或者提邀请，像一个客户对待他的供应商那样交谈。客户团队应该代表系统的需求，而供应商团队据此设置计划。当客户团队所有的需求都被激发出来后，供应商团队就可以决定实现它们的时间表。如果认为一些需求非常重要，那么应该先实现它们，延迟其他的需求。客户团队还需要输入和能被供应商团队分享的知识。这个过程 Flows one way，但是有时是必要的。

**两个子系统之间的接口需要预先明确定义。**另外还要创建一个统一的测试集，在任何接口需求被提出的时候用于测试。供应商团队可以在他们的设计上大胆地工作，因为接口测试集的保护网会在任何有问题的时候报警。

## 顺从者

如果管理没有清晰地界定在两个团队之间需要完成什么，或者管理很差，或者就没有管理，供应商慢慢地会越来越关心它的模型和设计，而也越来越疏于帮助客户。当两个开发团队有客户-供应商关系，而且供应商团队没有动力为客户团队的需要提供帮助时，客户团队是无助的。

如果客户不得不使用供应商团队的模型，而且这个模型做得很好，那么就需要顺从了。客户团队遵从供应商团队的模型，完全顺从它。

这和共享内核很类似，但有一个重要的不同之处。客户团队不能对内核做更改。他们只能用它做自己模型的一部分，可以在所提供的现有代码上完成构建。

当有人提供一个丰富的组件，并提供了相应的接口时，我们就可以将这个组件看作我们自己的东西构建我们的模型。如果组件有一个小的接口，那么最好只为它简单地创建一个适配器，在我们的模型和组件模型之间做转换。这会隔离出我们的模型，可以有很高的自由度去开发它。

## 防崩溃层

我们会经常遇到所创建的新应用需要和遗留软件或者其他独立应用相交互的情况。

因此，在我们的模型和遗留模型之间就须要有一个集成层，这也是使用旧应用的需求之一。

让我们的客户端系统和外面的系统交互有很多种方法。一种是通过网络连接，两个应用需要使用同一种网络通信协议，客户端需要遵从使用外部系统使用的接口。另外一个交互的方法是数据库。外部系统使用存储在数据库里的数据。

数据语义非常重要，并且需要被充分考虑。客户端应用不能访问数据库，也不能不理解被使用数据的含义就进行写入操作。我们看到外部模型的部分数据被反映在数据库里，然后进入我们的模型。

从我们模型的观点来看，防崩溃层是模型很自然的一部分，并不像一个外部的什么东西。它对概念和行为的操作和我们的模型类似，但是防崩溃层用外部语言和外部模型交流，而不是客户端语言。这个层在两个域和语言之间扮演双向转换器，它最大的好处在于可以使客户端模型保持纯洁和持久，不会受到外部模型的干扰。

我们怎么实现防崩溃层？一个非常好的方案是将这个层看作从客户端模型来的一个服务。使用服务是非常简单的，因为它抽象了其他系统并让我们在自己的范围内定位它。服务会处理所需要的转换，所以我们的模型保持独立。考虑到实际的实现，可以将服务看作比作一个 Facade（参见 Gamma et al 在 1995 年写作《 设计模式 》 ） 。 除 了 这 一 点 ， 防 崩 溃 层 最 可 能 需 要 一 个 适 配 器（Adapter）。适配器可以使你将一个类的接口转换成客户端能理解的语言。在我们的这个例子中，适配器不需要一定包装类，因为它的工作是在两个系统之间做转换。

防崩溃层也许包含多个服务。每一个服务都有一个相应的 Facade，对每一个 Facade 我们为之增加一个适配器。我们不应该为所有的服务使用一个适配器，因为这样会使我们无法清晰地处理繁多的功能。

我们还必须再增加一些组件。适配器将外部系统的行为包装起来。我们还需要对象和数据转换，这会使用一个转换器来解决。它可以是一个非常简单的对象，有很少的功能，满足数据转换的基本需要。如果外部系统有一个复杂的接口，最好在适配器和接口之间再增加一个额外的 Facade。这会简化适配器的协议，将它和其他系统分离开来。

## 独立方法

独立方法模式适合一个企业应用可由几个较小的应用组成，而且从建模的角度来看彼此之间有很少或者没有相同之处的情况。它有一套自己的需求，从用户角度看这是一个应用，**但是从建模和设计的观点来看，它可以由有独立实现的独立模型来完成**。我们应该现看看需求，然后了解一下它们是否可以被分割成两个或者多个不太相同的部分。

如果可以这样做，那么我们就创建独立的界定上下文（Bounded Context），并独立建模。这样做的好处是有选择实现技术的自由。

在继续谈论独立方法之前，我们需要明确的是我们不会回到集成系统。独立开发的模型是很难集成的，它们的相通之处很少，不值得这样做。

## 开放主机服务

当我们试图集成两个子系统时，通常要在它们之间创建一个转换层。这个层在客户端子系统和我们想要集成的外部子系统之间扮演缓冲的角色。这个层可以是个永久层，这要看关系的复杂度和外部子系统是如何设计的。

如果外部子系统不是被一个客户端子系统使用，而是被多个服务端子系统的话，我们就需要为所有的服务端子系统创建转换层。所有的这些层会重复相同的转换任务，也会包含类似的代码。当一个子系统要和其他许多子系统集成时，为每一个子系统定制一个转换器会使整个团队陷入困境。会有越来越多的代码需要维护，当需要做出改变时，也会越来越担心。

解决这一个问题的方法是，将外部子系统看作服务提供者。如果我们能为这个系统创建许多服务，那么所有的其他子系统就会访问这些服务，我们也就不需要任何转换层。问题是每一个子系统也许需要以某种特殊的方式和外部子系统交互，那么要创建这些相关的服务可能会比较麻烦。

定义一个能以服务的形式访问你子系统的协议。开放它，使得所有需要和你集成的人都能获取到。然后优化和扩展这个协议，使其可以处理新的集成需求，但某团队有特殊需求时除外。对于特殊的需求，使用一个一次性的转换器增加协议，从而使得共享的协议保持简洁和精干。

即使在我们提炼和创建很多抽象之后，一个大的领域还是会有一个大的模型。就是在重构多次之后，也依然会很大。对于这样的情况，就需要精炼了。思路是定义一个代表领域本质的核心域（CoreDomain）。精炼过程的副产品将是组合领域中其他部分的普通子域（Generic Subdomain）。

当我们处理一个大的模型时，应该试图将本质概念从普通概念中分离出来。一开始我们举了一个关于飞空中交通监控系统的例子。我们说飞行计划包括飞机必须遵照的设计好的路线。在这个系统里，路线好像是一个无时不在的概念。实际上，这个概念是一个普通的概念，不是本质上的。路线概念被用在许多领域里，可以设计一个普通的模型去描述它。

空中交通监控的本质在其他地方。监控系统知道飞机要遵照的路线，但是它还会接收跟踪飞行中飞机的雷达网络输入。。这个数据显示飞机真正遵照的飞行路线，而它经常和预先描述好的有些偏差。系统不得不基于飞机当前的飞行参数、飞机特点和天气情况来计算飞行轨道。计算飞机轨道的终极目的是看看是不是会和其他飞机的飞行路线有交叉。根据已有的数据同
步飞机轨道的模块才是这个业务系统的“心脏”。可以将它标识为核心域。路线模型更像是一个普通域。

**系统的核心域要看我们如何理解系统。一个简单的路线系统会将路线和与它相关概念看作核心域，而空中交通监控系统却把它们看作普通子域。一个系统的核心域有可能会变成另一个系统的普通子域。正确标识核心，以及它和其他模型之间的关系是非常重要的。**

精炼模型。找到核心域，发现一个能轻松地从支持模型和代码中区分核心域的方法。强调最有价值和特殊的概念。使核心变小。

将你所有的才能都投入到核心域上，不停地努力，找到一种深刻的模型，做一个足够灵活的设计以满足系统的远景。根据其他部分对提炼后核心的支持，判断投资。

让最好的开发人员去承担核心域的任务是重要的。开发人员经常沉溺于技术，喜欢学习最好的和最新的语言，相对于业务逻辑他们更关注基础架构。领域的业务逻辑于他们毫无兴趣可言，也看不到什么回报。还记得我们前面所谈的飞机轨道案例的要点吗？当项目完成时，所有的知识都成为毫无意义的过去。但是领域的业务逻辑是业务的核心所在。这个核心的设计和实现中如果有了错误，将会导致整个项目的失败。**如果核心业务逻辑不起作用，所有的技术亮点都等于垃圾。**

每个领域使用其他领域使用的概念。钱和它们相关的概念，比如行情和汇率，可以被包含在不同的系统里。图表是另外一个被广泛使用的概念，就它本身而言是非常复杂，但是可以被用在许多应用中。有下面集中方法可以实现普通子域

1. 购买现成的方案。 这个方法的好处是可以使用别人已经做好的全套方案。随之而来的是学习曲线的问题，而且这样的方案还会引入其他麻烦。比如如果代码有bug，你只得等待别人来解决。你还需要使用特定的编译器和类库版本。和自己系统的集成也不是那么容易。
2. 外包。将设计和实现交给另外一个团队，有可能是其他公司的。这样做可以使你专注于核心域，从处理其他领域的重压下释放出来。不便的地方是集成外包的代码。需要和子域通信的结构需要预先定义好，还要和外包团队保持沟通。
3. 已有模型。一个取巧的方案是使用一个已经创建的模型。世面上已经有一些关于分析模型的书，可以作为我们子域的灵感来源。直接复制原有的模型不太现实，但确实有些只需要做少许改动就可以用了。
4. 自己实现。这个方案的好处是能够做到最好的集成，但这也意味着额外的付出，包括维护的压力等。

另外还要注意下面几个领域建模时的陷阱：

1. 事必躬亲。模型需要代码。
2. 专注于具体场景。抽象思维需要落地于具体案例。
3. 不要试图对任何事情都进行领域驱动设计。画一张范围表，然后决定哪些应该进行领域驱动设计，哪些不用。不要担心边界之外的事情。
4. 不停地实验，期望能产生错误。模型是一个创造性的流程。
